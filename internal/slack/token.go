package slack

import (
	"context"
	"sync"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/ssm"
	"github.com/pkg/errors"

	"go.alexhamlin.co/randomizer/internal/awsconfig"
)

// TokenProvider provides the value of the slash command verification token
// generated by Slack.
type TokenProvider func(ctx context.Context) (string, error)

// StaticToken uses token as the expected value of the verification token.
func StaticToken(token string) TokenProvider {
	return func(_ context.Context) (string, error) {
		return token, nil
	}
}

// AWSParameter retrieves the expected value of the verification token from the
// AWS SSM Parameter Store, decrypting it if necessary, and caches the retrieved
// token value for the provided TTL.
func AWSParameter(name string, ttl time.Duration) TokenProvider {
	var (
		mu        ctxLock
		token     string
		retrieved time.Time
	)

	return func(ctx context.Context) (string, error) {
		cfg, err := awsconfig.New(ctx)
		if err != nil {
			return "", err
		}

		if !mu.LockWithContext(ctx) {
			return "", ctx.Err()
		}
		defer mu.Unlock()

		expiry := retrieved.Add(ttl)
		if time.Now().Before(expiry) {
			return token, nil
		}

		output, err := ssm.NewFromConfig(cfg).GetParameter(ctx, &ssm.GetParameterInput{
			Name:           aws.String(name),
			WithDecryption: true,
		})
		if err != nil {
			return "", errors.Wrap(err, "loading verification token parameter")
		}

		retrieved = time.Now()
		token = *output.Parameter.Value
		return token, nil
	}
}

// ctxLock is a mutual exclusion lock that allows clients to cancel a pending
// lock operation via a context. The zero value is an unlocked lock.
type ctxLock struct {
	init sync.Once
	ch   chan struct{} // buffered, size 1
}

// LockWithContext attempts to lock l. If the lock is already in use, the
// calling goroutine blocks until l is available or ctx is canceled. The return
// value indicates whether the lock was actually acquired; if false, ctx was
// canceled before the lock was acquired, and the caller must not unlock l or
// violate any invariant that l protects.
func (l *ctxLock) LockWithContext(ctx context.Context) bool {
	l.init.Do(func() {
		l.ch = make(chan struct{}, 1)
		l.ch <- struct{}{}
	})

	select {
	case <-l.ch:
		return true
	case <-ctx.Done():
		return false
	}
}

// Unlock unlocks l.
func (l *ctxLock) Unlock() {
	select {
	case l.ch <- struct{}{}:
		return
	default:
		panic("unlock of unlocked ctxLock")
	}
}
